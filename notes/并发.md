# 并发



- 可见性：一个线程对共享变量的修改，另一个线程能够理科看到
- 当两个线程并行执行加法（比如循环10000000)的时候，他的值会更加接近于10000000 ，而不是20000000。（个人理解，因为线程有交替运行的时候，就是一个线程运行，而另一个线程没有运行，此时只有一个线程运行的时候，就会让数值单独增加一会，然后另一个线程起来，读取这个值到缓存（应该是每一段时间，cpu缓存中的数值就会刷新到内存中），两个线程在一起跑，他们都只读自己cpu缓存中的数值，而不读内存中的，此时就导致 要加的数据以期增加。因此 他的结果接近1000000 而不是20000000. 其实也就是下边的cpu时间片的机制
- **至于什么时候把数据从缓存写到内存，没有固定的时间**
- cpu时间片：一个线程执行一段时间，就交给另一个线程在执行一段时间。每一段时间就是一个cpu时间片

count+1  需要的CPU指令数：

1. 把变量从内存加载到CPU的寄存器
2. 在寄存器中进行+1操作
3. 将结果写入内存/缓存

因为上述原因的存在，当cpu进行切换的时候，就很容易产生bug

![image-20210131135431911](../picture/image-20210131135431911.png)

- 有序性：编译器调整代码执行的先后循序：例如对于new指令来说：

  1. 分配一块内存地址
  2. 在内存地址上初始化对象
  3. 将此内存地址赋值给指向这个对象的指针

  然后编译器优化成了：

  1. 分配一块内存地址
  2. 将此内存地址赋值给指向这个对象的指针
  3. 在内存地址上初始化对象

于是这就出了问题。（对于双重检查的单例来说）此时如果a线程再执行完b步骤之后，就把权限给了c。此时c拿到的就是一个没有初始化的变量，一用就出问题了。

![image-20210131135943265](../picture/image-20210131135943265.png)

除了编译器有序性优化外：CPU和解释器在运行期也会做一部分优化，所以很多时候都是看不到的，也很难重现

**因此很多的并发问题都是：原子性，可见性，有序性所引发的，他们是并发bug之源，要想写好多线程一定要打破这三个条件，我们要解决的就是这三个问题**

**在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。**

## java内存模型

java内存模型：解决**可见性**和**有序性**导致的问题

掌握java内存模型，有助于解决 可见性和有序性引发的问题。

- 导致可见性的 原因是缓存，导致有序性的问题是编译优化。解决这两个最直接的方式：**全部禁用缓存和编译优化**，但这明显不合理
- 所以我们要按需禁用缓存和编译优化->因为何时禁用只有程序员知道，所以**按需就是按照程序员的要求禁用**。
- 为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。
- 站在程序员的角度：java内存模型可以理解为：**java内存模型规范了jvm如何提供按需禁用缓存和编译优化的方法**
- 这些方法包括：volatile，synchronize，final 三个关键字，以及六项Happend-Before原则。

### volatile

> 告诉编译器：不能使用cpu缓存，必须从内存中读取或写入

- Happen-Before：**前面的一个操作的结果对后续操作是可见的**

- Happen-Before约束了编译器的优化行为，运行其优化，但是要符合规则

#### 1.程序的循序执行

> 在一个**线程**中，按照程序顺序，前面的操作Happen-Before于后续的任意操作，一个线程内保证语意的串行性（即如果b依赖于a  那么 a一定先与b 执行，但是 如果 a和b没有依赖关系，则不一定）
> 在一个线程内，按照控制流顺序，书写在前面的操作先行 发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循 环等结构。

因此 对于一些没有前后依赖关系的代码，就可以进行指令重排序了

```java

// 以下代码来源于【参考1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
```

上述代码中 在同一个线程里 x =42 就要先用v=true执行，

### 2：volatile变量规则

> 对一个volatile的写操作，Happen-Before于对这个变量的读操作

对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见，这怎么看都是禁用缓存的意思

### 3.传递性

> 如果 A Happen-Before B  B Happen-Before C  那么 A  Happen-Before C

如下图所示，传递性的效果

![image-20210131153433499](../picture/image-20210131153433499.png)

“x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；

写变量“v=true” Happens-Before 读变量 “v=true”，这是规则 2 的内容 。

再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。这意味着什么呢？如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。也就是说，线程 B 能看到 “x == 42” ，有没有一种恍然大悟的感觉？这就是 1.5 版本对 volatile 语义的增强，这个增强意义重大，1.5 版本的并发工具包（java.util.concurrent）就是靠 volatile 语义来搞定可见性的，这个在后面的内容中会详细介绍。

个人理解：假设只有一个线程运行，那么     x = 42;v = true; 没有语义的先后循序 ，因此可以进行指令重排序

当有两个线程的时候，同时 v 被标注为 volatile 的时候，就给v以及在v之前进行的赋值操作，强制加了一个语义循序（依赖于 happen-before 第三条），因此 才能肯定读到v=42

指令重排序：在cpu执行指令的过程中，对于同一个线程中没有`数据依赖`的指令可以重新排序优化，有数据依赖的指令按照顺序串行执行，来保证单线程程序运行的正确性，同时也提升了CPU的执行效率，合理的利用了CPU等待时间，

我理解 volatile 就是在cpu指令级别上，加了一个写锁，在对volatile对象进行写入的时候，加上了写锁，所有读都必须等待其写完之后，才能读取

**volatile的执行方式**

第一：使用volatile关键字会强制将修改的值立即写入主存；
第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。

那么线程1读取到的就是最新的正确的值。

这也就是 为什么 他不能保证i++的正确性，但是能让i++变得离正确性更近一点

### 管程中