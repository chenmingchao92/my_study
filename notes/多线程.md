# 多线程

kill -9 给进程发送一个信号，如果进程实现了接受这个信号的机制，就关闭

kill -3 

java里的线程，其实是一个裸线程，只要java里的一个线程被new出来，他都对应这操作系统中的一个真正的线程

守护线程出现的原因：他用来做一些功能性的工作，比如定时查询，垃圾回收，然后守护线程还会随着主线程的毁灭而毁灭（主线程都死了，你作为他的守护现场，或者还有啥意义）

Thread类本身就实现了Runnable接口

CPU是以时间片的方式来运行的，就是一个线程运行一段时间，就切换其他的线程继续运行

Thread.sleep 释放cpu时间片，不释放锁

Object.wait：释放锁



为什么 wait和notify是放到Object基类中的而不是Thread类中的呢

线程Ready和Running状态是不可区分的，超出类我们编码控制的范围，是因CPU给你时间片你就能运行，不给你 你就要处于ready状态

join会释放当前执行的线程的锁（就是从那个线程里调用的join）

synchronized 加载方法上 或者代码块（不指定对象） 相当于加了this ，如果是静态方法，则是相当于加了类对象

关于 join的例子 可以中间加上 sleep  然后 用jstack -l 来查看线程状态

乐观锁好处：他讲 加锁-业务操作-解锁的操作 转化成了  一次操作，在压力不大的时候（就是大多数操作只需要自旋一次就能成功），效果很好，但是压力太大的时候，抢资源的线程过多，他自旋的次数过多，可能还不如 正常的加锁。

乐观锁就是赌一把，堵他没有变，变了的话就在赌一把