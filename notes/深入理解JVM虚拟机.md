# 深入理解JVM虚拟机

### java基本技术体系

jpc官方定义的java技术体系如下：

- Java程序设计语言
- java虚拟机栈
- class文件
- java类库api
- 第三方java类库

jdk包括如下：

- java程序设计语言
- jvm虚拟机
- java类库

jre包括的内容如下：

- jvm虚拟机
- java类库api中的 java se 子集

### 不同时代的java虚拟机

- classic虚拟机是java第一代虚拟机，他只能进行解释执行，或者外jit 。但是两者只能执行一个，因此他如果用解释执行，就会造成启动快，但是运行慢，如果用jit，为了避免启动过慢的问题，对编译的结果不能过度优化。
- exact jvm 是 java第二代虚拟机，他支持 准确是内存管理，就是可以直接分辨出来 这块区域存的是数字123，还是引用的值123，这样就不会吧数字误认为是引用，从而造成错误的操作，他可以解决用句柄二次访问造成性能下降的问题，同时它还支持热点探测技术，就是针对执行次数多的方法或者有效循环次数多的，就会触发发标准即时编译和栈上替换编译
- hotspot 虚拟机是现在主流的虚拟机，他之前的功能和exact差不多，它之所以胜利 是政治原因，不是技术原因。
- rockit虚拟机是一个更关注服务端性能的虚拟机，因此他不支持解释执行，只支持即时编译 -BEA公司的
- j9是IBM公司的  j9和Hotspot一样 同时关注 桌面，服务段，嵌入式三端的虚拟机，j9虚拟机的模块化和职责分离，通用性。比Hotspot虚拟机做的更优秀。
- zing虚拟机：Azul Systems公司产品， 他从旧版的Hotspot基础上重新开发而来，他在低延迟快速预热的场景都比Hotspot做得好，同时他的PCG和C4垃圾收集器实现了 TB级别内存 <10ms以内收集完毕的能力，zing虚拟机的ready now技术可以利用项目之前运行的性能数据，在项目再一次重新启动的时候，引导虚拟机预热，快速得到高性能稳定水平，zing可以让底层用户无需了解 jvm垃圾收集底层调优就享受低延迟，快速预热，易于监控的功能
- Dalvik虚拟机是安卓早起的虚拟机，他虽然并没有按照java虚拟规范开发（比如利用寄存器架构而不是栈架构），也不能解析class文件，但是他解析的Dex文件支持从class文件转化而来，支持用java语法编译程序，支持绝大部分java的api，不过后来 ART提前编译技术崛起，比即时编译能获得更好的性能，他就被ART取代了。

### java展望未来

> java的稳固的地区来自于他庞大的用户群体和极其成熟的软件生态环境

互联网之JavaScript ，人工智能之Python，微服务风之golang

- Graal VM 目的：可以作为任何一门语言的运行平台使用，如 Python kotlin  c rust  JavaScript ，ruby Python等各类语言，Graal VM可以毫无额外开销的混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言用已经编写好的本地库文件。
- C1：即时编译器：编译耗时短，但输出代码优化程度较低的 客户端即时编译器
- C2：即时编译器：编译耗时长，但输出代码的优化程度较高的服务端及时编译器
- graal编译器：即时编译器，用来替代C2，他能有效地借鉴C2的优势，C2能做的他都能做，同时他的扩展性和开发效率更高，还支持部分逃逸分析这种高级操作

可以使用-XX:UnlockExperimentalVMOptions -XX:UseJVMCICompiler参数来启动Graal编译

- 在微服务的视角下，一个大型的应用可能被拆分成多个小型的应用，所以他就不需要面对数十上百G的内存管理，同时有个高可用集群，也不要求单个服务7*24小时运行，他可以随时的中断和更新，这都和java需要的启动时间长，需要时间预热性能才能起来相违背，在无服务架构中，这个问题可能更加严重。
- 应对以上问题，java推出了 类似于 zing的readynow（我认为）的类型信息共享技术，允许吧加载解析后的类型信息缓存起来，从而提升下次启动的速度，无操作的垃圾回收器（只做内存分配，不做回收，对用完就关闭的应用十分合适），更狠的是逐步开始对提前编译提供支持。
- 提前编译是相对于即时编译而言的，提前编译就是jvm虚拟机可以直接加载运行这些已经预编译好的二进制库，而不用等待即时编译将其变异成二进制码，他可以减少jvm的预热时间。减少jvm第一次运行慢的不良体验，可以放心大胆的进行很多全面的分析，提高编译优化质量。但是提前编译的坏处也很明显，它破坏了Java“一次编写，到处运行”的承诺，必须为每个不同的 硬件、操作系统去编译对应的发行包；也显著降低了Java链接过程的动态性，必须要求加载的代码在 编译期就是全部已知的，而不能在运行期才确定，否则就只能舍弃掉已经提前编译好的版本，退回到 原来的即时编译执行状态。



## 自动内存管理

### java内存区域与内存溢出异常

> java虚拟机再执行java程序的时候，会把所管理的内存划分为若干个不同的数据区域，这些区域有各自的用于，创建，销毁时间，有的区域随着虚拟机进程的启动一直存在，有的区域则依赖于用户线程的启动和结束而建立和销毁。
>
> ![image-20210115002348809](D:\my_study\my_study\picture\image-20210115002348809.png)

它分为 线程共享的：方法区，堆，和线程私有的，虚拟机栈，本地方方法栈、程序计数器器

- 程序计数器：它是一块娇小的内存空间，可以看做当前线程所执行的字节码的行号，他控制整个指令的执行流程，例如循环，判断，跳转都是通过改变程序计数器的值来实现的。
- 程序计数器是线程私有内存，因为一个处理器一般来说，只能执行一个线程，同时为了线程切换之后可以继续执行之前的内容，每个线程就需要一个独立的程序计数器。
- 如果正在执行本地方法，这个计数器则为空，同时这个快内存是jvm规范唯一没有规定 oom的区域

### Java虚拟机栈

- 线程私有，生命周期和线程一样，每个方法被执行，Java虚拟机都会同步创建一个栈帧，用来存储，局部变量表，操作数栈，动态链接，方法出口等信息
- 每一个方法从执行到完毕的过程，就是一个栈帧从入栈到出栈的过程。
- 局部变量表存储了编译器可知的Java虚拟机的各种基本类型（byte，char，int，long，float，double，boolean，short）和对象引用（指针）和returnAddress类型（指向了一条字节码指令的地址）。
- 这些类型在局部变量表中 以slot（槽）的形式来存储，除了 long和double占两个slot，其他的类型只占一个槽位，同时局部变量表的大小在编译期就可以确定大小了，在方法运行期间这个大小也不会改变，这里说的大小事slot的数量，不同的虚拟机可能按照一个slot占用32位或64位，或更多来实现
- 如果程序请求的栈深度，大于jvm允许的栈深度，就会报错 stackoverflowError，
- 如果jvm虚拟机可以动态扩容，当栈扩展时无法申请到足够多的内存，会抛出OutOfMemoryError异常(Hotspot虚拟机不支持栈动态扩展)
- 栈第一次申请失败，也会出现这个问题

### java堆



- java堆中是用来存储对象的实例，java中几乎所有的对象实例都是在堆上进行内存分配的。
- java堆是垃圾收集器的管理区域，这里关于 新生代，老年代，永久代，Eden去，from，to区只是实现垃圾收集的一种实现理念，并不是jvm虚拟机规范中要求的，例如G1收集器就没有用到经典的分代收集理念。
- java堆中还有一个 TLAB里边，就是为每个线程专门开辟一段空间，专门做这个线程的对象内存分配，这样做是为了减少访问内存冲突，提高对象分配性能。
- java堆可以物理上不连续但是逻辑上连续，但是对于大对象和数组来说，为了实现方便，依然会选择一片连续的内存区域。

### 方法区

- 方法区也是所有线程共享的区域
- 用于存放虚拟机已经加载的类的类型信息，常量，静态变量，即时编译后的代码缓存区等数据
- jvm规范说方法区是堆的一个逻辑部分，但是我们管他叫非堆，好和java堆区域区分出来
- java8之前，方法区叫永久代，Hotspot选择将永久代和堆一起实现，这就导致了永久代有大小限制，通过-XX:MaxPermSize指定大小，这就导致了他很容易 发生oom
- java用 元空间 代替了永久代
- java虚拟机规范，同样要就这里不需要连续的空间，可以选择是否动态扩展，而且这块可以不垃圾回收，如果进行垃圾回收，也是对常量池和类卸载进行回收，因此效果并不好，但是之前因为这个区域没有回收，出过好几次问题

### 运行时常量池

- 运行时常量池是方法区的一部分，用来存放类加载后 类中的常量池表（存放，字面值（：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）还有被final修饰的静态，实例，局部变量）和符号引用）
- 同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。
- 运行时常量池存储的字符串和其他final修饰的类型，也是一个引用（这也就是为什么 final int 在常量池中村委 Integer),实际它的对象是在堆中创建的。
- 如果比较的 Integer的值 在-128和127之间，那么==可以直接用， 如果不是，那么==号就不灵了。
- 运行时常量池的另一个特性就是具备动态性，可以在运行时动态的将数据加入常量池中，如string的intern()方法。
- 不同的类共用一个运行时常量池，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，只会存在一份在运行时常量池中，这也是一种优化。

常量池详解连接：https://cloud.tencent.com/developer/article/1450501

![image-20210115231557526](D:\my_study\my_study\picture\image-20210115231557526.png)

- class文件常量池的大部分数据会被加载到运行时常量池，包括 String的字面量，但同时也会在非堆区域的字符串常量池中存储一份一样的引用，而String的字面量本地也在堆中创建。
- 当主线程创建一个新的字符串s1的时候，他会先去字符串常量值中找 是否有equals(s1)的字符串，有就直接将这个字符串的引用复制给s1,如果找不到，那么就创建一个，然后将引用复制一份到字符串池中。

### 字符串常量池的本质：

字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。

**运行时常量池在方法区(Non-heap)，而JDK1.7后，字符串常量池被移到了heap区（我觉得是为了方便进行垃圾回收），因此两者根本就不是一个概念。**z

- String.intern()方法会返回遇到的第一个字符串常量池中的相同字符串的引用，加入 字符串常量池已经有了一个 叫java的字符串，那么我们在顶一个一个          String str2 = new StringBuilder("ja").append("va").toString();（注意必须是前边的这种格式，如果是new的话，不好使，因为s2不改变他的变量值，他永远指向堆中的new的对象，除非 Intern（）一下，才会进入字符常量池）,然后 s2.intern() == s2 会返回false 因为 s2.intern()会返回第一个在字符串常量池中存在的那个 ‘java'字符串

```java
String t = new String("tt");
```

- 我们上面说过，"tt"属于字面量，那么它会在类加载之后存在于字符串常量池中，也就是说，在 String t = new String("tt")这句代码执行**之前**，字符串常量池就已经创建了"tt"这个字符串对象了，我们都知道，new这个关键字会在堆中创建一个对象。

- String.intern()是判读如果常量池有这个常量，那么就返回常量池中那个常量的 引用（需要主动接受），否则就将当前字符串的值加入到常量池中，然后在讲这个加入后的常量池数据返回

- 包装类的
  "=="运行符在不遇到算术运算的情况下不会自动**拆箱**，以及他们的equals()方法不处理数据类型的关系，可以推断出如果遇到“==”两边有算术运算是话就会自动拆箱和进行数据类型转换处理

```java
System.out.println(c.equals(a+b)); //a 和b 是Integer类型
```

- Long类型的equal在比较是时候，会先判断a+b是否为Long类型，显然a+b不是，因此false
- **运行时常量池是方法区的一部分而已**。并不是类的所有信息都放在方法区中

### java基本类型封装类和对应的常量池

- java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象

### 直接内存

- 直接内存不是虚拟机运行时数据区的一部分，也不是jvm虚拟机规范中定义的内存区域，这块内存也会发生oom异常
- 本机直接内存的分配不会受到java堆的限制，但是还是会受到物理机总内存和处理器寻址能力的限制的。

### HotSpot虚拟机在java堆中对象分配，布局，访问的过程

1. 当遇到一条new指令的时候，虚拟机先去运行时常量池看一眼，有没有这个符号引用，以及这个符号引用对应的类有没有被加载，连接，初始化，如果没有，就要先执行相应的加载过程。
2. 类在加载检查通过后，便为类分配内存，类在加载完毕后便可以确定所需内存大小，因此直接将一个符合要求大小的堆内存分配给这个类，java分配内存有两种方式
   1. 指针碰撞，假设java堆是有规律的，被对象占用的站一边，空闲的内存地址站一边，那么我们要做的只是将指向空内存地址开头的指针，移动类需要的内存大小距离即可
   2. 空闲列表：如果java堆中已使用的内存和空闲的内存相互交错到一起，就没法用指针碰撞了。就需要用一个空闲列表来维护空闲内存的地址，然后当给对象分配内存的时候找一块足够大的内存分给内存。
   3. 指针碰撞相对简单和高效。
3. 实际山给对象分配内存，容易引起资源冲突，可能刚给A分配完内存，指针还没来得及修改，对象B有用原来的指针地址进行内存分配，解决这个问题的方式有两种：
   1. 对分配的内存进行同步处理-java虚拟机采用的cas来保证的。
   2. TLAB的方式，为每个线程专门分配一个空间，这个线程的所有对象都在这个专门的空间中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定，可以通过 -XX:+/-UseTLAB参数来设定。
   3. 内存分配完毕以后，jmv必须将分配的内存的值都初始化为零，TLAB可以在分配给线程的时候，就初始化为0了，这一步保证java对象的实例字段在不赋初值就可以使用，访问到数据类型所对应的零值。
   4. 设置对象头：这个对象属于哪个类的实例，如何才能找到元数据信息，对象的哈希码（实际上会等到真正调用hashcode的时候才会计算），对象的GC分代年龄等信息
   5. 上述工作完成后，从虚拟机的角度看，一个对象已经创建完毕了，但是从java程序角度来看，新对象才刚刚开始，因为构造行数，就是class文件中的<init>()方法还没有执行，所有的字段都默认为零值，对象需要的其他资源和状态信息也没有按照预定的意图构造好，一般来说 new指令（jvm虚拟机在遇到new关键字后会生成两个指令，一个new  就是到分配内存，初始化内存区域为0 的步骤，一个invokespecial指令则会调用构造方法）之后会紧跟着执行<init>()方法，按照程序员的意图对对象进行初始化赋值，这样一个真正可用的对象才被创造出来。

### 对象内存得布局

可以分为三类：对象头，实例数据，对齐填充

java的对象头中存储两类信息：

1. 存储对象自身的运行时数据，如哈希码，GC分带年龄，锁状态标识，线程持有的锁，偏向线程ID，这部分在32为的虚拟机里长度为32为，同理64为，同时为了节省空间，jvm对对象头采用了动态定义的数据接口，就是同一个空间，对于不同的值，标识不同的含义，例如01：未锁定，00：轻量级锁定，10：重量级锁定等，他们哦堵在同一个空间存储
2. 类型指针：对象指向它类型元数据的指针，jvm通过这个指针来确定该对象是那个类的实例。但是并不是所有的jvm虚拟机都需要这个东西，同时，如果对象类型是数据，还需要存放数组的长度
3. jvm虚拟机可以通过java对象的元数据来确定java对象的大小。

java的实例数据：

- java实例数据存储的是从父类继承来的和自己的的字段内容，虚拟机有字段的分配策略（-XX:FieldsAllocationStyle参数）.
- java虚拟机总是将相同宽度的字段分配到一起，在满足前面的前提下，然后父类的字段在子类的前面。
- -XX:CompactFields参数允许子类字段插入福类字段的缝隙中，以节省内存。

java的内存对齐

Hotspot要求内存对象的其实地址必须是8的整数倍，也就是任何对象的大小都要是8的整数倍，对象头我们发现它被设计成了8字节的整数倍，内存对齐就是将不够8的整数倍的对象，调整成8的整数倍

### 对象的访问定位

主流的对象访问定位方式有两种：1.使用句柄，2.直接指针

- 句柄：如果使用句柄，java堆可能会划分出一块内存作为句柄池，reference引用中存储的就是对象句柄的地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息：![image-20210116020001934](D:\my_study\my_study\picture\image-20210116020001934.png)
- 直接指针访问：reference中存储的直接就是对象地址，此时就要求对象头中存有元数据指针的地址了。这样能减少一次（和句柄方式比较）间接访问的开销![image-20210116020315377](D:\my_study\my_study\picture\image-20210116020315377.png)

- 句柄的好处就是：reference中存储的是稳定句柄地址，在对象发生移动的时候，只会改变句柄池中的数据，reference本身不用变化，直接指针的优势是速度快，毕竟减少了一次间接访问

- Hotspot采用的是直接指针的方式，但是在各种语言和框架中 句柄也很常见。

- Hotspot虚拟机中不区分虚拟机栈和本地方法栈：因此对与Hotspot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但没用，栈容量（注意不是栈帧）只由-Xss指定。栈容量在不同的机器上，最小值有不同的限制

- 当然hotstop的栈也是可能发生oom的，只要我们不停的分配线程，因为操作系统分配给进程的内存有限，那么只要坚持不懈，就能发生oom。

- java进程占用的内存= 最大java堆+直接内存+虚拟机进程+元空间（非堆）

- **如果因为建立了过多的线程导致内存溢出，可以通过减少堆的最大值来临时解决**

- ·-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存 大小。之所以有这个是为了防止有玩命创建类的疯子 进行破坏操作。

- jdk8中，将字符串常量池从 方法区 移动到了java堆中
- ·-XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集 进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放 了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该 值。 （ps：这里的意思是不是 垃圾收集器实际也是会对元空间进行手机操作）
- ·-XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可 减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最 大的元空间剩余容量的百分比。
- 直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不 去指定，则默认与Java堆最大值（由-Xmx指定）一致，
- 由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常 情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了

## 垃圾收集器和内存分配策略

> 垃圾收集器需要完成的三件事：那些内存需要回收，什么时候回收，如何回收

> 当需要排查各种内存泄漏，溢出问题时，当垃圾收集器成为系统打到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术，实施必要的监控和调节

- 对于线程栈来说，每一个栈帧占多少内存，基本上在类结构确定下来，就已知了，因此 pc计数器，本地方法和虚拟方法栈的分配和回收都具有确定性，基本上方法或线程结束了，内存也就回收了。
- 对于java堆和方法区（因为类信息都在这上边）而言，在这上边创建的对象的大小和数量都是未知的，只有在运行时，我们才知道程序究竟会创建多少对象，那些对象，因此这部分内存的分配和回收是动态的。垃圾收集器就是关注这部分的

### 那些内存需要回收（确认死没死）

- **引用计数法**：给对象添加一个引用计数器，当对象每被引用一次，技术就加一，当引用失效时，计数就减一，任何时刻计数为0的引用就不可能在被引用，就可以被回收，这个方法简单高效，例如Python语言就用了引用计数法，但是java并没有用这个方法，因为这个简单的方法要考虑很多其他因素，比如循环引用的问题就很难搞定

- system.gc()可以手动触发GC
- **可达性分析方法**：java主要采用的方式，实现：他通过一些列被称为GC Root的根对象作为起始点，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径，被称为引用链，如果某个对象和GC Root之前没有任何引用链项链，那么就证明这个对象不可达

- 固定可作为GC Root的对象包括如下几种

  - 在虚拟机栈（栈帧中的局部变量表）中引用的对象，譬如各个线程被调用的方法栈中使用到的参数 ，局部变量，临时变量等。
  - 在方法区中：类静态属性引用的对象，比如java类引用类型静态变量
  - 在方法区中：常量引用的对象，譬如字符串常量池里的引用
  - 在本地方法栈中JNI（native方法）引用的对象
  - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 
  - ·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 
  - ·所有被同步锁（synchronized关键字）持有的对象。 
  - ·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

  除了上述固定GC Root 以外，根据用户所选垃圾收集器不同，和内存区域的不同，还会加入一些临时根，例如分代收集，对新生堆收集的时候，里边的一些对象可能被老年代所引用，这是后就要将这些关联区域的对象也一起加入到GC Root中。

### java引用

java将引用分为 **强引用**和 **软引用** **弱引用** **虚引用** 这四种引用强度 逐步递减

- 强引用： new Object() 就是一个强引用，无论任何情况下，只要强引用关系还在，拉垃圾回收器就不会回收。
- 软引用：用来描述一些现在还在用，但非必须的对象，只被软引用关联的对象，在系统将要发生内存溢出之前，就会将这些对象列入回收范围中进行二次回收，如果这次回收还没有足够的内存，就会抛出异常  SoftReference类来实现软应用。
- 弱引用：弱引用也是用来描述那些非必须的对象的，它的强度比弱引用弱，他只能存活到下一次垃圾回收为止，当垃圾收集器开始工作，无论内存是否够用，他都会被回收 通过WeakReference类来使用
- 虚引用：也称为幽灵引用，一个对象是否有虚引用的存在完全不会对其生存周期产生影响，也无法通过虚引用来取的一个对象的实例，虚引用的唯一目的就是该对象被垃圾收集器回收时收到一个系统通知。PhantomReference类来实现虚引用

### 两次标记致死

第一次通过GC Root标记 并不会立刻致死，虚拟机会判断他的 如果它覆盖了finalize方法，同时虚拟机还没有执行过这个方法，他就会被加入一个 专门用来执行 finalize方法的 F-Queue队列中执行这个队列的线程优先级很低，同时虚拟机也不保证类的finalize一定会执行完毕，因为谁知道是不是程序员会在里边搞破坏，比如死循环，这样后边所有的finalize都没法执行了，如果再执行finalize方法的时候，类能主动将this赋值给一个确定存活的对象，那么在收集器对F-Queue队列进行第二次标记的时候，他就逃脱了。

这种自救的机会只有一次，因为对象的finalize方法只会被虚拟机执行一次。 

**要尽可能的避免使用 finalize函数**它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为 不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize() 方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、 更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。

### 回收方法区

- 方法区由于回收的要求苛刻，所以回收的效率很差，JDK11的ZGC收集器就不支持类卸载功能。

- 方法区的垃圾回收主要回收两部分：废弃的常量和不再使用的类型，

- 对于常量回收：例如一个字符串“java”增进入常量池，但是现在没有任何一个字符串对象的值是“java”，换句话说没有任何字符串对象的值引用常量池中的“java”，且虚拟机中也没有任何地方引用这个字面量，如果这时候发生垃圾回收，虚拟机判断有必要回收，这个“java”常量就会被移出常量池。

  ```java
  
  	public static void main(String[] args) {
  		String a = null;
  		for (int i = 0; i < 30000000; i++) {
  			a = i+"";
  			a.intern();
  		}
  		a = new String("22")+new String("2");
  		String c = a.intern();
  		System.out.println(c == a); //这里会打印true 这就证明 字符串常量池也会被垃圾回收
  	}
  ```

- 常量池中的其他类（接口），方法，字段的**符号引用**也与此类似

判断一个类是否被使用需满足一下三个条件：

- java堆中不存在任何该类和派生类的信息。
- 加载该类的类加载器已被回收
- 该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

只有满足了上述三个条件，jvm虚拟机规范才允许类被回收，但是并不和类一样，没了引用就要一定回收。

- jvm虚拟机提供了-Xnoclassgc参数进行控制，  -XX:+TraceClass-Loading查看类的加载信息  -XX:TraceClassUnLoading来查看类卸载信息。 -verbose：class也可以查看类的加载信息。

## 垃圾收集算法

- 从如何判定对象死亡的角度出发，垃圾收集可以分为：引用计数式垃圾收集（直接垃圾收集）和追踪式垃圾收集（间接垃圾收集）。jvm虚拟机未采用引用计数，所以jvm的垃圾收集都是 追踪式垃圾收集

### 分代收集理论

> 分代收集名为理论，实际上是一套符合大多数程序运行的经验法则

- 弱分代假说：绝大多数对象都是朝生息灭
- 强分代假说：熬过越多次垃圾收集的对象，就越难被消灭
- 夸代引用假说：夸代引用相对于同代引用来说，只占极少数（解决夸代引用问题的假说）

如果一个区域的对象 大多数都是朝生熄灭，那么虚拟机只需要关注如何存留那些少量的活下来的对象，而不用大量的标记那些将被回收的对象，就能以较低的代价回收大量的内存，将活的久的对象放到一起，虚拟机就能较低频率的光顾这个地方。减少不必要回收的时间。

- Minor GC Major GC Full GC 这样的回收分类，以及 标记-复制，标记-清除，标记-整理都是源于分代理论。
- 对象之间不是孤立的，对象之间存在夸代引用。
- 因为老年代可能会引用年轻代的对象，因此每次垃圾回收都遍历整个老年代是可行的，但是很影响性能。
- 根据夸代引用假说。我们就没必要为了少量的引用去扫描整个老年代，同时也没必要为每个对象专门浪费空间记录是否存在夸代引用，以及存在那些夸代引用。只需要在新生代上建立一个全局的数据结构，将老年代划分成一个个的小块，只需要表示出老年代的哪个小块可能存在夸代引用，在收集年轻代垃圾的时候，只需要将这个小块内存的对象当做临时根即可。
- 部分收集：指目标不是完整收集整个java堆的垃圾收集，其又分为：
  - 新生代收集（Minor GC/Young GC)：指目标只是新生代的垃圾收集
  - 老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集，目前只有CMS收集器有单独收集老年代的行为
  - 有时候 Major GC  还是指为整堆收集
  - 混合收集（Mixed GC） 指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有G1收集器有这种行为
  - 整堆手机（Full GC） 手机整个java堆和方法区的垃圾收集

*通常能单独发生收集行为的只是新生代，所以这里“反过来”的情况只是理论上允许，实际上除了 CMS收集器，其他都不存在只针对老年代的收集。*

### 标记-清除算法

- 标记-清楚算法是最基础的算法：算法分为标记和清除两部分：首先标记处所有需要清除的对象，在标记完成之后，在同一回收这些标记的 对象，或者 标记不需要清除的对象，将所有没有标记的对象清除。

标记清楚算法有两个缺点：

- 随着空间的变大，需要标记清楚的对象的数量增加，它的效率会越来越差
- 因为清除的对象不是连续的，因此会产生大量的不连续的内存碎片，空间碎片太多可能会造成分配较大对象的时候，找不到合适的连续区域，从而不得不提前触发一次垃圾收集

### 标记-复制算法

标记复制算法是将内存分为两块，每次只用其中的一块内存，当这块内存满了的时候，就将其中存活的对象复制到另一个区域，然后将之前的内存直接清空即可，如果每次都有很多对象存活，那么这种方式会产生大量的内存复制的开销，但是对于多数对象都被回收的情况，这种算法的复制开销就很小，也不用整理内存，直接移动堆顶指针分配即可。

- 根据IBM的研究，新生代的对象98%都熬不过第一轮垃圾收集
- 新生代分为 Eden 和两块Survivor空间，每次分配内存只用Eden和其中的一块Survivor，发生垃圾收集的时候将这两个区域存活的对象，复制到另一个survivor中，然后以此循环
- Hotspot默认的Eden和Survivor分配大小为8：1，就是新生代每次可用的可分配空间为整个新生代容量的90%。
- 分配担保：当survivor中的空间不够存储存活的对象的时候，就需要别的空间进行来容纳这些存活对象，一般这个区域就是老年代
- Serial和ParNew就是采用的这种策略。

### 标记-整理算法

根据老年区的对象存亡特征，采用标记整理算法，他的前部分逻辑和标记清楚算法一样，只不过他不是直接清除掉无效对象，而是将所有存活的对象都望内存一端移动，然后直接清理所有对象移动完毕后剩余的那一部分内存即可。

是否移动存活的对象是一项优缺点并存的风险决策

- 如果移动存活的对象，因为老年区每次都有大量的存活对象，移动这些对象并更新引用将是一种负重很大的操作，而且这样的移动对象必须全程暂停用户应用进程，着就是 STW stop The world
- 如果用比较-清除那样，完全不考虑清除完的内存碎片问题，就要用更复杂的内存分配方案来解决内存分配的问题：例如：“分区空闲分配链表”来解决内存分配问题。（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘 上存储和访问就是通过硬盘分区表实现的），但是内存是用户最频繁访问的区域，如果 在这个地方增加复杂操作，**势必会影响吞吐量**
- 因此，如果选择移动对象，就在内存回收的时候，更加复杂，如果不移动对象，就在内存分配的时候更加复杂
- 从垃圾收集的停顿时间来看，移动对象会增加应用程序的停顿时间。不移动对象会使得收集器的效率提升一些，**但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降**。不移动对象的话，**甚至可以**不需要暂停应用进程。
- Hotspot关注吞吐量的ParallelScavenge是基于标记-整理算法的（上述粗体部分说明了原因）
- 关注时延的CMS收集器是基于标记-清除算法实现的，这也从侧面映射了 标记-清除和标记整理的区别
- 另外还有一种和稀泥的解决方案：就是让虚拟机平时用标记-清除算法 ，当内存碎片化的程度已经影响到内存分配的时候，再进行一次标记-整理方法  其实CMS收集器在面临碎片过多的回收，就采用的这种方法

### Hotspot虚拟机算法实现细节

> 根节点枚举的时候，是要世界暂停的。

- **根节点枚举**：我们知道固定可作为GC root的 为 全局性的引用（常量，类静态属性）以及执行山下文（局部变量表）但是，虚拟机中，对象和常量等的数量 多如恒沙，如果全部都查询一边，那么必定会花费很长时间，而且 枚举GC root 的时候 是必要的暂停应用进程的，这是为了保证根节点枚举的一致性，如果在枚举根节点的时候，对象的应用关系还在发生变化，也就无法保证枚举节点的准确性，同时后续的回收工作也就不准确了，所以GC root枚举的时候，需要 stop the world
- 对于 上述说的枚举节点过多的问题，因为现在的虚拟机都是准确内存模型，也就是知道每一个内存是不是引用，这样Hopstop的做法是维持了一个 oomMap 一但类加载完成，他也就知道了这个类的每个偏移量的数据是什么类型，如果是引用类型，就加入oomMap中，并记录这是一个什么类型的引用（例如是普通引用还是静态引用）。这样在枚举根节点的时候，就不用全都查找一遍，直接走oomMap就可以了。
- 可达性分析算法（java标记对象死活，就用的这个算法，还有一个指针引用）中耗时最长的查找引用链的过程已经可以做到和用户线程一起并发了。

### 记忆集和卡表

- 记忆集是用来记录从非收集区域指向收集区域的指针集和的数据结构

记忆集记录精度的可供选择如下：

- 字节长度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针
- 对象精度：每个记录精确到一个对象，这个对象的字段中包含夸代指针
- 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

上述第三种 卡精度 是一种卡表的实现方式，这也是最常见的记忆集的实现方式，记忆集知识一种抽象的数据结构，他只定义了记忆集的行为意图，卡表是记忆集的一种具体实现。 就好像 hashMap和map一样

- 卡表最简单的方式可以只是一个字节数组，Hotspot就是这么干的。Hotspot是这样创建 卡表的 

  ```c
  CARD_TABLE [this address >> 9] = 0;
  ```

  这里用地址 >> 9 就是相当于 用地址 除以512 而这个结果 要和卡表的索引能对上，所以 可以得知 hotstop的卡页取的是512

- 只要卡页中有一个对象中的字段存在夸代引用，就将他对应的卡表中的值 变为1。默认为0表示没有，这样 Gc  root的时候 只要找卡表中为1的卡页中的对象，就可以了。

### 写屏障

jvm虚拟机通过写屏障，来维护卡表的变脏操作

- **写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面**，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的 前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值 后的则叫作写后屏障（Post-Write Barrier）这样虚拟机在发现了 夸代引用的时候，直接通过写后屏障（G1之前收集器只用了写后屏障）来更新卡页对应的卡表即可。
- 应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新 卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外 的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。

### 并发的可达性分析

枚举根节点在各种优化措施加持下，以及本来根节点的个数也少，所以他的停顿时间很短，也相对固定（就是不随堆的增加而增加）

- 从GCroot再往下遍历，遍历的时间，必然和堆的大小成正比，堆越大，存储的对象越多，对象图越复杂，，要标记更多对象而产生的停顿时间自然就更长
- 标记阶段是所有追踪式垃圾回收器所必需的，如果这个阶段随着堆增大而等比例增加停顿时间，其影响就会波及所有垃圾收集器，如果能减弱这部分的手机时间，那收益也很大

标记阶段三色分析法，黑色标识 GC Root 和已经完全扫描过并确认存活的节点，白色标识还没有被扫描过的节点，灰色表示扫描了一部分，但是至少还有一个节点没有被扫描的对象，当完全扫描完毕后，依然为白色的对象就是垃圾

![image-20210117165051914](D:\my_study\my_study\picture\image-20210117165051914.png)

，

上图中 最后两种情况是 jvm标记过程和用户应用一起运行的时候，可能会发生的问题。

收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果。一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理 掉就好。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此 发生错误。

当且仅当以下两个条件**同时满足**的时候，才会产生“对象消失”的问题，即原本是黑色的对象被误标位白色。

1. 赋值器插入了一条到多条从黑色对象到白色对象的新引用
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

所以我们破坏上述两个条件之一即可，因此可以分为两种方式：增量更新->破坏的是第一条，原始快照：破坏第二条

- 增量更新：当黑色对象插入新的指向白色对象的引用关系时，就将这个新 插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。
- 原始快照：，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象（最初的快照中的那个对象，这种对象中的引用关系并没有收到后续用户操作的影响）为根，重新扫描 一次
- CMS是基于增量更新的，G1和Shenandoah 是根据原始快照的来实现的.
- 也就是上 cms  G1  shenandoah 虚拟机 在标记对象的时候,可以和应用程序一起进行.
- 无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的

## 经典垃圾收集器

![image-20210117173221930](D:\my_study\my_study\picture\image-20210117173221930.png)

如果两个收集器之间存在连线,就证明两个可以一起使用,由于维护和兼容性的成本，在JDK 8时将Serial+CMS、 ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持

- CMS和G1是最广泛使用又复杂的垃圾收集器
- 现在还没有一种 最好的垃圾收集器,只有针对不同的场景的最适应的

### Serial收集器

serial收集器是最老的,历史最悠久的收集器.他是单线程的收集器.也是因此他在收集垃圾的时候,会暂停用户进程.直到他收集结束.

![image-20210117174638358](D:\my_study\my_study\picture\image-20210117174638358.png)

Serial收集器，是目前Hotspot安装在客户端模式下的默认新生代收集器，他简单高效，对内存资源受限的环境，他是所有收集器里边额外消耗内存最少的。对于单线程处理器，或者处理器核心数较少的，它能减少线程切换的开销。可以获得最高的单线程收集率

在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚 拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的 内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一 百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以， Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

### parNew收集器

parNew收集器就是serial收集器的并行版本。除了使用多条线程以外，其他的和serial收集器完全一样。

![image-20210117180724504](D:\my_study\my_study\picture\image-20210117180724504.png)

除了Serial以外，只有ParNew和Serial收集器能和CMS收集器一起工作。CMS收集器只收集老年代（是Parallel Scavenge收集器及 后面提到的G1收集器等都没有使用HotSpot中原本设计的垃圾收集器的分代框架，而选择另外独立实 现。Serial、ParNew收集器则共用了这部分的框架代码。）

可以说直到CMS的出现才巩固了ParNew的地位，但成也萧何败也萧何，随着垃圾收集器技术的不 断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不 再需要其他新生代收集器的配合工作。所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方 推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代，甚至还取消了ParNew加 Serial Old以及Serial加CMS这两组收集器组合的支持（其实原本也很少人这样使用），并直接取消了XX：+UseParNewGC参数，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能 够和它们配合了。读者也可以理解为从此以后，ParNew合并入CMS，成为它专门处理新生代的组成部 分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。

parNew收集器在单核和超线程实现的伪双核上，都不一定比serial收集器效果更好

-XX:ParallelGCThreads 来限制parNew的核心数

在谈论垃圾收集器的上下文语境中，它们可以理解为： ·并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。 ·并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于 垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

-XX:UseConcMarkSweepGC 启动cms收集器