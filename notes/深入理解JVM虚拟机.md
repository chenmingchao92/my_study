# 深入理解JVM虚拟机

### java基本技术体系

jpc官方定义的java技术体系如下：

- Java程序设计语言
- java虚拟机栈
- class文件
- java类库api
- 第三方java类库

jdk包括如下：

- java程序设计语言
- jvm虚拟机
- java类库

jre包括的内容如下：

- jvm虚拟机
- java类库api中的 java se 子集

### 不同时代的java虚拟机

- classic虚拟机是java第一代虚拟机，他只能进行解释执行，或者外jit 。但是两者只能执行一个，因此他如果用解释执行，就会造成启动快，但是运行慢，如果用jit，为了避免启动过慢的问题，对编译的结果不能过度优化。
- exact jvm 是 java第二代虚拟机，他支持 准确是内存管理，就是可以直接分辨出来 这块区域存的是数字123，还是引用的值123，这样就不会吧数字误认为是引用，从而造成错误的操作，他可以解决用句柄二次访问造成性能下降的问题，同时它还支持热点探测技术，就是针对执行次数多的方法或者有效循环次数多的，就会触发发标准即时编译和栈上替换编译
- hotspot 虚拟机是现在主流的虚拟机，他之前的功能和exact差不多，它之所以胜利 是政治原因，不是技术原因。
- rockit虚拟机是一个更关注服务端性能的虚拟机，因此他不支持解释执行，只支持即时编译 -BEA公司的
- j9是IBM公司的  j9和Hotspot一样 同时关注 桌面，服务段，嵌入式三端的虚拟机，j9虚拟机的模块化和职责分离，通用性。比Hotspot虚拟机做的更优秀。
- zing虚拟机：Azul Systems公司产品， 他从旧版的Hotspot基础上重新开发而来，他在低延迟快速预热的场景都比Hotspot做得好，同时他的PCG和C4垃圾收集器实现了 TB级别内存 <10ms以内收集完毕的能力，zing虚拟机的ready now技术可以利用项目之前运行的性能数据，在项目再一次重新启动的时候，引导虚拟机预热，快速得到高性能稳定水平，zing可以让底层用户无需了解 jvm垃圾收集底层调优就享受低延迟，快速预热，易于监控的功能
- Dalvik虚拟机是安卓早起的虚拟机，他虽然并没有按照java虚拟规范开发（比如利用寄存器架构而不是栈架构），也不能解析class文件，但是他解析的Dex文件支持从class文件转化而来，支持用java语法编译程序，支持绝大部分java的api，不过后来 ART提前编译技术崛起，比即时编译能获得更好的性能，他就被ART取代了。

### java展望未来

> java的稳固的地区来自于他庞大的用户群体和极其成熟的软件生态环境

互联网之JavaScript ，人工智能之Python，微服务风之golang

- Graal VM 目的：可以作为任何一门语言的运行平台使用，如 Python kotlin  c rust  JavaScript ，ruby Python等各类语言，Graal VM可以毫无额外开销的混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言用已经编写好的本地库文件。
- C1：即时编译器：编译耗时短，但输出代码优化程度较低的 客户端即时编译器
- C2：即时编译器：编译耗时长，但输出代码的优化程度较高的服务端及时编译器
- graal编译器：即时编译器，用来替代C2，他能有效地借鉴C2的优势，C2能做的他都能做，同时他的扩展性和开发效率更高，还支持部分逃逸分析这种高级操作

可以使用-XX:UnlockExperimentalVMOptions -XX:UseJVMCICompiler参数来启动Graal编译

- 在微服务的视角下，一个大型的应用可能被拆分成多个小型的应用，所以他就不需要面对数十上百G的内存管理，同时有个高可用集群，也不要求单个服务7*24小时运行，他可以随时的中断和更新，这都和java需要的启动时间长，需要时间预热性能才能起来相违背，在无服务架构中，这个问题可能更加严重。
- 应对以上问题，java推出了 类似于 zing的readynow（我认为）的类型信息共享技术，允许吧加载解析后的类型信息缓存起来，从而提升下次启动的速度，无操作的垃圾回收器（只做内存分配，不做回收，对用完就关闭的应用十分合适），更狠的是逐步开始对提前编译提供支持。
- 提前编译是相对于即时编译而言的，提前编译就是jvm虚拟机可以直接加载运行这些已经预编译好的二进制库，而不用等待即时编译将其变异成二进制码，他可以减少jvm的预热时间。减少jvm第一次运行慢的不良体验，可以放心大胆的进行很多全面的分析，提高编译优化质量。但是提前编译的坏处也很明显，它破坏了Java“一次编写，到处运行”的承诺，必须为每个不同的 硬件、操作系统去编译对应的发行包；也显著降低了Java链接过程的动态性，必须要求加载的代码在 编译期就是全部已知的，而不能在运行期才确定，否则就只能舍弃掉已经提前编译好的版本，退回到 原来的即时编译执行状态。



## 自动内存管理

### java内存区域与内存溢出异常

> java虚拟机再执行java程序的时候，会把所管理的内存划分为若干个不同的数据区域，这些区域有各自的用于，创建，销毁时间，有的区域随着虚拟机进程的启动一直存在，有的区域则依赖于用户线程的启动和结束而建立和销毁。
>
> ![image-20210115002348809](D:\my_study\my_study\picture\image-20210115002348809.png)

它分为 线程共享的：方法区，堆，和线程私有的，虚拟机栈，本地方方法栈、程序计数器器

- 程序计数器：它是一块娇小的内存空间，可以看做当前线程所执行的字节码的行号，他控制整个指令的执行流程，例如循环，判断，跳转都是通过改变程序计数器的值来实现的。
- 程序计数器是线程私有内存，因为一个处理器一般来说，只能执行一个线程，同时为了线程切换之后可以继续执行之前的内容，每个线程就需要一个独立的程序计数器。
- 如果正在执行本地方法，这个计数器则为空，同时这个快内存是jvm规范唯一没有规定 oom的区域

### Java虚拟机栈

- 线程私有，生命周期和线程一样，每个方法被执行，Java虚拟机都会同步创建一个栈帧，用来存储，局部变量表，操作数栈，动态链接，方法出口等信息
- 每一个方法从执行到完毕的过程，就是一个栈帧从入栈到出栈的过程。
- 局部变量表存储了编译器可知的Java虚拟机的各种基本类型（byte，char，int，long，float，double，boolean，short）和对象引用（指针）和returnAddress类型（指向了一条字节码指令的地址）。
- 这些类型在局部变量表中 以slot（槽）的形式来存储，除了 long和double占两个slot，其他的类型只占一个槽位，同时局部变量表的大小在编译期就可以确定大小了，在方法运行期间这个大小也不会改变，这里说的大小事slot的数量，不同的虚拟机可能按照一个slot占用32位或64位，或更多来实现
- 如果程序请求的栈深度，大于jvm允许的栈深度，就会报错 stackoverflowError，
- 如果jvm虚拟机可以动态扩容，当栈扩展时无法申请到足够多的内存，会抛出OutOfMemoryError异常(Hotspot虚拟机不支持栈动态扩展)
- 詹孔建第一次申请失败，也会出现这个问题