并发编程就是解决一个问题 就是性能问题
比如我们干打的项目 就是堆人 类似
都需要 分工  协作  互斥
第一步一定是做好分工  有些地方分工完了就行了 例如 分流量
第二步 一定在有一个节点 要等其他的线程执行完 这就是最简单的协作    countdownlanch 就是协作
有界队列也是  满了就要等其他现场来消费  这也是协作的关系
第三步 互斥 多个线程访问同一个共享变量 都需要互斥 否则就有并发问题

当我们的程序 正常的将cpu打满的时候，就证明到了程序极限了，cpu打满了，比cpu满的磁盘，网络也一定都打满了，也就将硬件的性能压榨干净了。

对于并发编程来说，操作系统和组成原来非常重要 深入理解计算机操作系统 计算机网络



所有性能问题 基本上都是IO问题。

进程 线程是操作系统干的事，是操作系统中的概念，操作系统中没有协序 协序 都是程序语言自己搞的。

协序能避免用户态和内核态频繁切换

不同的进程之间是相互隔离的，隔离一些共享的东西，内存的地址空间要隔离，文件，内存线程数据。让他们不相互影响。

进程和线程切换的成本太高了，协程切换的成本更低，他不需要切换到内核态，较低切换开销

阻塞是操作系统方面的说明，一但阻塞 就证明没有cpu的使用权

没有用户态的copy就是零copy

因为内存和io和cpu速度不一样，我们就让cpu多干点活，多个线程就是为了让cpu多干活

人一般都是找一个能锤炼自己的场景，比如想做大数据 就去找一个数据很大的公司，在这个场景里去锤炼