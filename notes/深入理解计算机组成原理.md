# 深入理解计算机操作系统

## 1.信息的表示和处理：

- 大多数计算机都是用8位的块（也就是一个字节）来表示**最低寻址单位**，而不是更基础的位，机器将内存看做一个非常大的字节数组，每个字节都有一个唯一数字表示的地址，这样的 **字节数组**成为*虚拟内存空间*(p24)
- 虚拟内存地址 只是表示给机器级程序看的虚拟影像 (p24)
- c语言的一个指针的值都是某个存储块的第一个字节的虚拟地址(p24)
- 尽管C语言维护者指针指向的数据的类型信息，但是它生成的实际机器级程序并不包含关于数据类型的任何信息，每个程序对象都可以简单的看做一个字节块，而程序本身就是一个字节序列

### 1.十六进制表示法

- ​	我们可以记住 A C F 这三个十六进制对应的二进制数，A为1010  C为1100  F为1111  这样对应的B D E 我们就能快速的推算出来： B = A +1 = 1010+1 = 1011  D = C +1 = 1100+1 = 1101  E=F-1 = 1111 -1= 1110
- 十进制转换成任何进制，都是不停的除以对应进制的数就可以了，然后不停的取余数，例如十六进制的如下图所示：![image-20210526214206936](D:\my_study\my_study\picture\image-20210526214206936.png)
- 同理，任何进制转换成十进制都是不听的乘以自己的进制数就可以了，如下所示，十六进制转十进制。![image-20210526214243511](D:\my_study\my_study\picture\image-20210526214243511.png)

### 2.*字*数据大小

每个计算机都有一个字长（word size），来表明指针的大小。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的一个系统参数就是 **虚拟地址空间**的大小。(p27)
$$
也就是说，对于一个字长为w的机器而言，其虚拟地址空间大小为2^w-1 单位为字节
$$

- 64位字长的计算机的可用虚拟内存空间为16EB 大约是1.84*10的19次幂，

- 32位机器上编译的程序也可以在64位的机器上运行，64位机器上编译的程序，却不能在32位上运行，因此，我们说的32位和64位指的是这个程序是编译的，例如  gcc -m32 prog.c 就是按照32位编译的机器，可以在64为上运行，反过来 gcc -m64 prog.c 编译的程序却不能在32位的机器上运行。(p27)

- c语言的数据类型与对应的字节长度：![image-20210527204041742](D:\my_study\my_study\picture\image-20210527204041742.png)

- int_32和int_64大小是固定的，不随着编译器和机器的设置而变化。

- 虽然char 是用来储存文本字符串中单个字符的，但是他也可以用来存储整数值

- c语言并不保证char 一定是一个有符号数，虽然其他数据类型默认为有符号数，因此使用的时候最好用 用 singed char 来声明

- 在c语言中，如下四种写法都是等价的，c语言对关键字的顺序没有绝对的要求

  ```c
  unsigned long int;
  unsigned long;
  long unsigned int;
  long unsigned;
  // 上述标识的都是 long类型 后边的int可以省略也可以不省略
  ```

- char * 标识的是一个指针，指向了类型为char 的变量 长度为机器的字节长度

- signed char * 用 %x打印的时候，会自动扩充符号位（因为按照整数打印的）。 unsigned char * 就不会

- 可以移植性的一方面就是程序对数据类型的确切大小不敏感

- 在c语言中，我们可以用数组表示法来引用指针，反过来也可以用指针表示法来引用数组。

- c语言中，去地址运算符& 创造一个指针。 表达式 &x创造了一个指向变量x的指针。

- void * 是一种特殊的指针类型，没有相关联的类型信息。

- 虽然数字分为大端机和小端机，但是 字符串却没有这种区分，他都是 最先书写的在前面，后书写的在后边（abcdef 的顺序永远都是abcdef）

### 3.寻址和字节顺序

对于跨越多个字节的程序对象，我们必须建立两个规则：

1. 这个对象的地址是什么，
2. 在内存中如何排列这些字节。

在几乎所有的机器上，多字节对象基本都被存储为连续的字节序列，对象的地址就是所使用字节中最小的地址。例如：

*一个int类型的变量x 地址为 0x100，那么在32为机器上，x的四个字节将被存储在内存的 0x100,0x101,0x102和0x103上*

排列表示一个字节的存储，通常有两个规则，一种是小端法：就是 **对象字节的第一个字节 位于该对象的最小地址位置**如下图所示 存储0x1234567的时候

![image-20210527210128051](D:\my_study\my_study\picture\image-20210527210128051.png)

大端法就是 **对象字节的第一个字节 在 对象存储的最高地址位置** 如下图所示：也是存储0x1234567

![image-20210527210230767](D:\my_study\my_study\picture\image-20210527210230767.png)

许多比较新的微处理器都是用的**双端法**

然而，虽然比较新的机器支持双端，但是 **一但选定了特定了操作系统，其字节顺序也就固定了**，例如 Android只能运行在小端机上。

在网络交互上，小端机和大端机的交互可能会出现问题，比如小端机产生的数据，发送到大端机就是反序的。这是网络标准要解决的问题。

对于程序编译成的机器二进制码，在不同的机器上，会编译成不同的机器码，因为不同的机器类型，使用不同切不兼容的指令和编码方式

如下所示：

![image-20210529094942843](D:\my_study\my_study\picture\image-20210529094942843.png)

可以看到，不同的机器上，编码完全不同，而且不同的操作系统之间，对相同的进程也会有不同的编码。因此二进制编码是不兼容的。很难移植

从计算机角度来看，程序仅仅是一个字节序列。机器没有关于任何源程序的相关信息

**位向量**：位向量就是 固定长度为w，又0或者1组成的串，例如：0111001010101010

位向量的运算可以定位为参数的每个对应元素之间的运算。例如：![image-20210529100119671](D:\my_study\my_study\picture\image-20210529100119671.png)

a和b就是位向量，他们的布尔运算就是按位运算

布尔运算的规则：

**a&(b|c) = (a&b)|(a&c)** 这和乘法对加法的分配律很像 a*(b+c) = a * b + a * c  但是 |对&也有分配律，就是  **a|(b&c) = (a|b)&(a|c)**,也就是说 对于 &和|来说，他的分配律是双向的，和我们的整数的不一样。

**加法逆元**：整数运算每个值 x 都有一个加法逆元 -x 使得：x+(-x) = 0;

**布尔环**：对于任何的值a来说 a^a = 0,  这里0表示，全为0 的位向量，

a^b^a  和 a^a^b 来说答案是一样的，都是b，也就是说他可以随意排列位置。



位向量可以表示 有限的整数集合。我们可以用位向量 [Aw-1.....A1,A0] 来编码任何子集B B属于{0,1,2...W-1},例如：

位向量[01101001]可以表示有限集合（0，3,5,6） 他们的规律是这样的，位向量从右往左看， 有限集合要从左往右看。 位向量一共8位，也就是w=8，因此 从左往右看，第0位为1，表示 整数集合中0这个数要出现，第1位第二位为0，因此整数集合中没有1和2，一次类推，也就是 在位向量中，如果一个向量值为1，则表示他在第几位，第几位这个数字就出现在整数的集合中。

当使用上述这种方式的时候，布尔运算的 | 和 & 就相当于集合运算的并集和交集。如下例子所示：

a=[01101001] b = [01010101] a&b = [01000001]   

A{0,3,5,6}  B{0,2,4,6}  A∩B = {0,6}  结果一致。

**在大量实际应用中，我们都能看到位向量对集合编码**

位运算的一个常见操作，就是实现**掩码**运算。

java中 x>>>k 标识的是逻辑右移

对于一个32的机器来说，如果右移的位数 超过了32的话，会发生什么呢，实际上，要位移多少位的值，是通过 k mod w 来计算的。

k就是我们指定的位移的位数，w就是我们机器的字长，例如 如果我们指定的位移为36位，那么实际要进行的位移操作就是36 mod 32 = 4；

## 2整数表示

整数取值范围 有一个特点，负数的取值范围比整数的取值范围的 >1

### 1.无符号数的编码

![image-20210529180339197](D:\my_study\my_study\picture\image-20210529180339197.png)

![image-20210529180439819](D:\my_study\my_study\picture\image-20210529180439819.png)

无符号数有一个很重要的特性，就是 介于0-2w-1之间的数，都有一个唯一的二进制编码，例如十进制的11对应唯一个无符号二进制编码[1011],因此 **无符号数编码具有唯一性**，也就是函数 B2Uw(X) 是一个 **双射**

### 2.补码

补码是无符号位向量的另一种表示形式，他可以表示负数值。

![image-20210529180934310](D:\my_study\my_study\picture\image-20210529180934310.png)

对于补码来说，补码的最小是为:

![image-20210529184237753](D:\my_study\my_study\picture\image-20210529184237753.png) 

 换算成位向量，也就是[1000...00] ,最大值为

 ![image-20210529184217126](D:\my_study\my_study\picture\image-20210529184217126.png)

换算成位向量也就是 [011111..111]

![image-20210529184401689](D:\my_study\my_study\picture\image-20210529184401689.png)

这也就是为什么，负数的取值范围比正数的取值范围大1的原因

补码同无符号码一样，也具有 **唯一性**

c语言中，单字节数据类型为char

**原码**：最高有效位是符号位，用来确定剩下的位是取正数还是负数。

因为 0是非负数，也就代表着 正数的范围比负数少一个。

### 3.有符号数和无符号数之间的转换

对于两只之间的转换，c语言是站在位级的角度上来考虑的，而不是数的角度。强制类型转换保证位不变，知识改变解释位的方式。

对于一个32位机器而言，一个数和其对应的强制类型转换的值，正好是 2的32次幂，其实这就是 求余数，余数就是在2的32次幂之内循环。例如 在16位数中，-12345的补码 无符号标识为：53191， 他们两个想加的绝对和正好为 2的16次幂。也就是0了。

因此 对于强制类型转换，就有了如下的两个公式：

- ![image-20210619154029999](D:\my_study\my_study\picture\image-20210619154029999.png)

![image-20210619154044757](D:\my_study\my_study\picture\image-20210619154044757.png)

![image-20210619154550207](D:\my_study\my_study\picture\image-20210619154550207.png)

在c语言中，当执行一个运算的时候，如果一个值是有符号数，另外一个是无符号数，那么c语言会隐式的将有符号数转换成无符号数。这种方式对于标准的算数运算来说，并无多大差异，但是对于比较(<  >) 来说会导致非直观的结果。

### 4.扩展一个数的位表示

- 要将一个无符号数扩展成一个更大的无符号数，只需要简单的在前面加0就可以了。这种运算被称为 **零扩展**
- 要将一个补码数字扩展一个更大的数字类型，可以执行一个 **符号扩展位** 在表示中添加最高有效位的值。

##### 5.无符号加法的溢出：

![image-20210619155921820](D:\my_study\my_study\picture\image-20210619155921820.png)

![image-20210619160008424](D:\my_study\my_study\picture\image-20210619160008424.png)

其实就是 以 2的w次幂为界限的余数

![image-20210619160043904](D:\my_study\my_study\picture\image-20210619160043904.png)

![image-20210619160158789](D:\my_study\my_study\picture\image-20210619160158789.png)

![image-20210619160454538](D:\my_study\my_study\picture\image-20210619160454538.png)

**可以用除法检验乘法的溢出。**