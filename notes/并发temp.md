### 4：管程中锁的规则

> 对一个锁的解锁Happens-Before于后续对这个锁的加锁

管程：管程是一种通用的同步原语，在Java中指的就是synchronized，synchronized就是java对管程的实现

这也就是先进入管程中的程序对管程中数据的操作，对于后续进入管程的程序来说，完全可见

锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。 实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。

一个线程对一个锁临界区执行完解锁后，变量的值对于另外线程后续对这个临界区做加锁操作时是可见的

### 5：线程start()规则

这是关于线程启动的，它是指主线程A启动子线程B后，子线程B能看到主线程A在启动B之前的操作

### 6：线程join()规则

这条是关于线程等待的，它是指主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现）当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程中的操作，即对“**共享变量**的操作”

换句话说就是，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。

volatile：禁用缓存和编译优化

final可以安全发布对象

“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程通过 global.obj 读取 x 是有可能读到 0 的。因此我们一定要避免“逸出”。

```java

// 以下代码来源于【参考1】
final int x;
// 错误的构造函数
public FinalFieldExample() { 
  x = 3;
  y = 4;
  // 此处就是讲this逸出，
  global.obj = this;
}
```

Happens-Before 的语义是一种因果关系。在现实世界里，如果 A 事件是导致 B 事件的起因，那么 A 事件一定是先于（Happens-Before）B 事件发生的，这个就是 Happens-Before 语义的现实理解

在java语言里，Happen-Before的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。

### 7:线程中断规则：

> 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。

，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题

final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的

所谓顺序，指的是你可以用顺序的方式推演程序的执行，但是程序的执行不一定是完全顺序的。编译器保证***结果***一定 == 顺序方式推演的结果 ->所以才造成了指令重排序

**这几条规则，都是告诉你，可以按照这个规则推演程序的执行。但是编译怎么优化，那就百花齐放了。**

volatile强制所修饰的变量及它前边的变量刷新至内存，并且volatile禁止了指令的重排序。