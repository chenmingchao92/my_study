# netty-极客时间

## 三种I/O模式

| BIO(同步阻塞IO)     | jdk1.4之前 | 同时阻塞线程和阻塞IO，无论IO是否准备好数据，线程都必须一直等待，等到IO准备好数据，然后复制到用户空间，才会停止阻塞 |
| ------------------- | ---------- | ------------------------------------------------------------ |
| **NIO(同步非阻塞)** | jdk1.4     | 不阻塞线程但是阻塞IO，当IO准备数据的时候，线程不需要阻塞，可以继续做自己的事情，当IO准备好以后，IO通知用户线程，用户线程去获取数据，进行处理 |
| AIO（异步非阻塞IO)  | jdk1.7     | 不阻塞线程，也不需要主动去IO中读取数据，当IO准备好数据后，还会将数据主动复制到用户空间，然后通知线程，直接使用数据即可（就是系统会将数据准备好，直接回调给我们） |
|                     |            |                                                              |

- 阻塞与非阻塞：没有数据读取过来的时候，读会阻塞一直到有数据；缓冲区满的时候，写操作也会阻塞，非阻塞遇到这种情况，都是直接返回的。
- 同步与非同步：数据就绪后需要自己去读就是同步，数据就绪后直接读好再回调给程序就是异步

![image-20210123104124550](D:\my_study\my_study\picture\image-20210123104124550.png)

上图中的COMMON是通用的NIO实现，就是依赖于jdk的NIO，然后后边的 两种 是netty的自己的实现，比如在linux下，虽然他们用的都是epoll，但是netty自己针对linux的自我实现，实现的更好例如：

- netty暴露了更多的可控参数，例如：JDK的nio默认是水平触发的，netty是边缘出发（默认）和水平出发可切换
- netty实现的垃圾回收更少，性能更好。

*什么是水平触发，边缘触发*

在非阻塞IO中，通过Selector选出准备好的fd进行操作。有两种模式，一是水平触发（LT），二是边缘触发（ET）。

在LT模式下，只要某个fd还有数据没读完，那么下次轮询还会被选出。而在ET模式下，只有fd状态发生改变后，该fd才会被再次选出。ET模式的特殊性，使在ET模式下的一次轮询必须处理完本次轮询出的fd的所有数据，否则该fd将不会在下次轮询中被选出，这时候就需要手动去再次取数据。

*为什么要删除AIO*

- AIO在window上实现很成熟，但是window很少用来做服务器
- Linux常用来做服务器，但是AIO实现不够成熟，而且Linux下AIO相比较NIO的性能提升不明显

*NIO一定优于BIO么*

BIO特点：

- BIO代码简单
- 在一些特当场经BIO很好用：连接数少，并发度低的场景，BIO性能不输NIO（相当于1对1的vip模式，一个线程服务一个连接）

所以 要根据具体场景使用具体技术。

*如何从NIO切换到OIO*

我们们只需要将netty启动类里的NioEventLoopGroup转换成 OioEventLoopGroup，再将NioServerSocketChannel变成OioServerSocketChannel即可

### JAVA自带的序列化技术存在的弊端

- java自带的序列化技术，只适用于java对象本身，如果跨语言就不行了
- 序列化后字节码字节码占用的空间过大。
- 序列化性能差，在编解码过程中要占据更好的cpu资源。

![image-20210124175107319](D:\my_study\my_study\picture\image-20210124175107319.png)

- IO传输模型：用什么样的通道将数据发送给对方：BIO还是NIO还是AIO 区别很大
- 数据协议：选择什么样的通信协议，差别也很大，例如选http还是内部私有协议，协议的选择不同，性能模型也就不同，一般来说或内部私有协议比共有协议性能更好
- 线程模型设计如何读取数据包，读取之后的编解码在那个线程中执行，编解码后的消息如何派发等方面，线程模型设计的不同，也会影响到性能。